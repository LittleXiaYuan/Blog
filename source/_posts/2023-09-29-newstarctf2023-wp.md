---
title: NewStarCTF2023 第一阶段题解
date: 2023-09-29 21:10:57
updated: 2023-10-04 21:47:57
slug: newstarctf2023-wp
categories:
  - 未分类
  - 小夏鸢的CTF日常喵
---

## 写在前面
今年这场比赛真的很精彩，作为新生赛，第一轮题目出的很好，覆盖知识点也广！

开篇先给各位✌嗑个头，呜呜呜椰奶✌带带咱走吧~！(跪倒)
![这 就 是 夏 鸢](https://me.owo.today/wp-content/uploads/2023/09/IMG_20230926_214301_217-300x184.jpg)

------------
## CRYPTO

#### 1.BrainFucker
作为Crypto板块的开篇题目，难度并不高，答案直接写在咱脸上了
BrainFucker编码格式：
```
明文：hello,world.
密文：+++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++++ .---. +++++ ++..+ ++.&lt;+ +++++ ++[-&gt;
----- ---&lt;] &gt;---. &lt;++++ ++++[ -&gt;+++ +++++ &lt;]&gt;++ +++++ ++++. ----- ---.+
+.-- ----. ----- ---.&lt; +++++ ++[-&gt; ----- --&lt;]&gt; ----- .&lt;
```
[BrainFucker](https://www.nayuki.io/page/brainfuck-interpreter-javascript)

#### 2.Caesar's Secert
跟题目写的基本一模一样，就是凯撒密码，拿到密文"kqfl{hf3x4w'x_h1umjw_n5_a4wd_3fed}"
凯撒密码，偏移值5，直接get flag(

[Caesar cipher](http://www.atoolbox.net/Tool.php?Id=778)

#### 3.Fence
啊~当然是一如既往的见字入面，一见如故的栅栏密码喵，那么，让我们看到题目，fa{ereigtepanet6680}lgrodrn_h_litx#8fc3

栏数2，得到```flag{reordering_the_plaintext#686f8c03}```

#### 4.Vigenère
一看到题目就能明白，是经典的Vigenère(维吉尼亚密码)
首先是拿到题目，

咱的话也没有废话，直接上字典，暴力跑密钥，用Python写了段简单的代码，如下
https://github.com/LittleXiaYuan/Vigenere-Passwd/

```python
import itertools

def vigenere_decrypt(ciphertext, key):
    decrypted_text = ""
    key_length = len(key)
    
    for i, char in enumerate(ciphertext):
        if char.isalpha():
            
            shift = ord(key[i % key_length].lower()) - ord('a')
            
            
            if char.isupper():
                decrypted_char = chr(((ord(char) - ord('A') - shift) % 26) + ord('A'))
            else:
                decrypted_char = chr(((ord(char) - ord('a') - shift) % 26) + ord('a'))
            
            decrypted_text += decrypted_char
        else:
            decrypted_text += char
    
    return decrypted_text

ciphertext = "pqcq{qc_m1kt4_njn_5slp0b_lkyacx_gcdy1ud4_g3nv5x0}" #密文
dictionary = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"  
max_key_length = 8  # 密钥范围

for key_length in range(1, max_key_length + 1):
    for key in itertools.product(dictionary, repeat=key_length):
        possible_key = "".join(key)
        decrypted_text = vigenere_decrypt(ciphertext, possible_key)
        if "flag{" in decrypted_text:
            print(f"Key: {possible_key}, Decrypted Text: {decrypted_text}")
            break
```
直接得到密钥为“KFC”，flag{la_c1fr4_del_5ign0r_giovan_batt1st4_b3ll5s0}

其实还有个邪门的做法，看"PQCQ" 对照翻译表，发现是明文Flag，在得知出明文和密文后直接逆推出密钥 得到Flag)

#### 5.babyencoding
好的那么首先~看到题目中有"encoding" 猜测是跟编码有关系...第一部分是Base64，因为有大小写混杂而且结尾还是=结尾
> base64的编码表是由（A-Z、a-z、0-9、+、/）64个可见字符构成，“=”符号用作后缀填充，可直接判断

得到前半部分为```flag{dazzling_encoding#4e0ad4```

看到第二部分，全部都是大写字幕，而且以"="结尾
> base32的编码表是由（A-Z、2-7）32个可见字符构成，“=”符号用作后缀填充

得到中间部分为```f0ca08d1e1d0f10c0c7afe422fea7```

第三部分一眼UUencode
> UUencode是一种二进制到文字的编码，最早在unix邮件系统中使用，全称：Unix-to-Unix encoding
举个例子：
明文：XiaYuan
密文：'6&EA675A;@``
`

故第三部分为```c55192c992036ef623372601ff3a}```
得到全部的Flag为：```flag{dazzling_encoding#4e0ad4f0ca08d1e1d0f10c0c7afe422fea7c55192c992036ef623372601ff3a}```
